/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 16.04.2 ] */

/* [wxMaxima: input   start ] */
load("Métodos.mac")$
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
g(x):= %e^x-1;
min:-2$  max:1$   tol:10^(-3)$
metodo:biseccion$

metodo(g,min,max,tol);
plot2d(g(x),[x,min,max]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Ejercicio 1
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
Tiene una única solución porque es monótona (f' > 0)
en (0,+infinito) y f(1)*f(2) < 0
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
g(x):= x^3 + 4*x^2 - 10;
biseccion(g,1,2,10^(-5));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Para conseguir un error menor que 10^(-8) tenemos
que hallar el menor n tal que (b-a)/2^(n+1) < 10^(-8)
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
ceiling(log((2-1)/10^(-8))/log(2) -1);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Ejercicio 3
   [wxMaxima: section end   ] */

/* [wxMaxima: subsect start ]
a) 3x = 2+x^2-e*^x
   [wxMaxima: subsect end   ] */

/* [wxMaxima: comment start ]
Tomamos como [a, b] el intervalo [0, 1/2].
Dado que:
 ·f(0)*f(1/2) < 0
 ·f'(x) = 3-2x+e^x != 0 (e^x > 0 y 3 - 2x > 0)
 ·f''(x) = -2+e^x < 0
 ·f(0)f''(0) > 0
el método de Newton-Raphson converge con x0 = 0 a la única raíz en [0, 1/2]
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
f(x):=3*x-2-x^2+%e^x$
newton_raphson(f,0,1/2,10^(-7));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: subsect start ]
b) x^2+10cos(x)+x=0
   [wxMaxima: subsect end   ] */

/* [wxMaxima: comment start ]
Tomamos [a, b] = [-4, -3].
Se tiene que:
 ·f(-4)*f(-3) < 0
 ·f'(x) = 2x-10sen(x)+1 != 0 ya que sen(x) no está en [-0.7, -0.5]: es decreciente
  y sen(-3) > -0.5
 ·f''(x) != 0 porque los x tales que cos(x) = 1/5 son de la forma
   +/-acos(1/5) + 2kpi con k entero, y no caen en el intervalo:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
makelist(float(acos(1/5)+2*k*%pi),k,-1,0);
makelist(float(-acos(1/5)+2*k*%pi),k,-1,0);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
 ·f(-3)f''(-3) > 0
el método de Newton-Raphson converge con x0 = -3 a la única raíz en [-4, -3]
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
f(x):=x^2+10*cos(x)+x$
define(ddf(x),diff(f(x),x, 2));
float(f(-3));
float(ddf(-3));
newton_raphson(f,-4,-3,10^(-7));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Ejercicio 6
   [wxMaxima: section end   ] */

/* [wxMaxima: input   start ] */
f(x) := x^3 - 3*x^2*2^(-x) + 3*x*4^(-x) - 8^(-x);
newton_raphson(f,0,1,10^(-1));
eulerm(f,0,1,10^(-1));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Ejercicio 9
   [wxMaxima: section end   ] */

/* [wxMaxima: input   start ] */
g1(x) := 1 - log(x)$
g2(x) := x + 1 - log(x)$
g3(x) := x - (1 - log(x))$
g4(x) := x + (1 - log(x))/3$
its: 1000$
tol: 10^(-4)$
x_0: 1$
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
float(%e);
makelist(itera([g1,g2,g4][i],its,tol,x_0),i,1,3);
itera(g3,its,tol,x_0);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Ejercicio 13
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
p(x) = q(x)(x-x0) + p(x0) => p'(x) = q'(x)(x-x0) + q(x) => p'(x0) = q(x0)
q(x) = r(x)(x-x0) + q(x0) => q'(x) = r'(x)(x-x0) + r(x) => q'(x0) = r(x0)
                          => p''(x)=q''(x)(x-x0)+2q'(x) => p''(x0)= 2q'(x0) = 2r(x0)

r(x) = s(x)(x-x0) + r(x0) => r'(x0) = s(x0) y p3'(x) = q3'(x-x0)+3q'(x)
                                                     = ...
Es decir, el k! de Taylor sale solo
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
_taylor(p, x, c, n):=block(
  [l_coef, ci, d:coeficientes(p(x))],
  for k:0 thru n do [l_coef[k],d]:horner(d, c),
  sum(l_coef[k]*(x-c)^k, k, 0, n)
)$
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
p(x):=x^5+3*x^3-x^2-x+4;
_taylor(p, x, 2, 4);
taylor(p(x),x,2, 4);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Ejercicio 18
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
De acuerdo con la teoría la función que utilizamos es:
g(x,y) = (y/raiz(5),1/4(sin(x) + cos(y)))
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
g18(v) := [v[2]/sqrt(5),(sin(v[1]) + cos(v[2]))/4];
itera(g18,1000,10^(-5),[1/4,1/4]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Ejercicio 20
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
La función que debemos definir es:
TODO: Comprobar que la segunda componente está bien (hay que despejar un cuadrado y
    no sé si estoy cogiendo el signo correcto)
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
load(linearalgebra);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
g20b : [1/6 + 1/3*cos(x2*x3), 
           1/sqrt(81)*sqrt(x1^2 + sin(x3) + 1.06), 
           1/20*((3 - 10*pi)/3 - %e^(-x1*x2))]$
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Definimos ahora el método de Newton modificado:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
newton_raphsonm(f,as,bs,tol,vars,iters) := block(
  [old:as, new:(as+bs)/2,Jf, eqs:[], n:0],
    for i:1 thru length(vars) do (eqs: cons(vars[i] = as[i], eqs)),
    Jf: invert(subst(eqs,jacobian(f,vars))), /* Jacobiana */
  while lmax(abs(old-new)) > tol and n < iters do (
    old: new,
    new: old-Jf.f(old),
    if f(new) = 0 then return(new)
  ),
  float(new)
)$
lmax(abs([1,1,1]));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Por último aplicamos el método
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
newton_raphsonm(g20b,[-1,-1,-1],[1,1,1],10^(-5),[x1,x2,x3],100);
/* [wxMaxima: input   end   ] */

/* Maxima can't load/batch files which end with a comment! */
"Created with wxMaxima"$
